{
  "hash": "eea37281d70d75b73d353383d2961703",
  "result": {
    "markdown": "---\ntitle: \"10 Comparaison des différentes méthodes, étude de cas réels\"\ntoc: true\n---\n\n\n# Préliminaires\n\nImportation de l'ozone\n\n::: {.cell}\n\n```{.r .cell-code}\nozone <- read.table(\"../donnees/ozone_complet.txt\", header = T, sep = \";\")\ndim(ozone)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1464   23\n```\n:::\n:::\n\n\nÉlimination des individus avec une valeur manquante\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindNA <- which(is.na(ozone), arr.ind = T)[,1]\nozone2 <- ozone[-indNA,]\n```\n:::\n\n\nImportation du fichier d'ozone sans valeurs manquantes avec les projections\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozone <- read.table(\"../donnees/ozone_transf.txt\", header = T, sep = \";\")\n```\n:::\n\n\net préparation du data-frame qui contiendra les résultats de chaque méthode\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRES <- data.frame(Y = ozone$maxO3)\n```\n:::\n\n\nPour le moment il ne contient qu'une seule colonne avec les données à prévoir.\n\n# Méthodes et comparaison\n\nNous séparons en 10 blocs en 2 étapes: création des affectations des individus à chaque bloc\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbbloc <- 10\nblocseq <- rep(1:nbbloc, length = nrow(ozone))\n```\n:::\n\n\nPuis nous utilisons une permutation aléatoire de ces affectations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbloc <- sample(blocseq)\nset.seed(1234)\nbloc <- sample(blocseq)\n```\n:::\n\n\n## Régression multiple\nChargement du package pour la sélection de variables\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaps)\n```\n:::\n\nEvaluation de la qualité prédictive de la régression linéaire et de la\nsélection de variables via BIC (algorithme exhaustif)\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:nbbloc){\n  ###MCO global\n  reg <- lm(maxO3~.,data=ozone[bloc!=i,])\n  RES[bloc==i,\"MCO\"] <- predict(reg,ozone[bloc==i,])\n  ###MCO choix\n  recherche <- regsubsets(maxO3~., int=T, nbest=1, nvmax=22, \n                                        data=ozone[bloc!=i,])\n  resume <- summary(recherche)\n  nomselec <- colnames(resume$which)[\n                       resume$which[which.min(resume$bic),] ][-1]\n  formule <- formula(paste(\"maxO3~\",paste(nomselec,collapse=\"+\")))\n  regbic <- lm(formule,data=ozone[bloc!=i,])\n  RES[bloc==i,\"choix\"] <- predict(regbic,ozone[bloc==i,])\n}\n```\n:::\n\n\n## Lasso, ridge et elasticnet\n\nChargement du package pour lasso, ridge et elasticnet\net création des matrices nécessaires à son utilisation :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glmnet)\nozone.X <- model.matrix(maxO3~.,data=ozone)[,-1]\nozone.Y <- ozone[,\"maxO3\"]\n```\n:::\n\n\nÉvaluation de la qualité prédictive des régressions lasso, ridge et elasticnet:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:nbbloc){  \n  XA <- ozone.X[bloc!=i,]\n  YA <- ozone.Y[bloc!=i]\n  XT <- ozone.X[bloc==i,]\n  ###ridge\n  tmp <- cv.glmnet(XA,YA,alpha=0)\n  mod <- glmnet(XA,YA,alpha=0,lambda=tmp$lambda.min)\n  RES[bloc==i,\"ridge\"] <- predict(mod,XT)\n  ###lasso\n  tmp <- cv.glmnet(XA,YA,alpha=1)\n  mod <- glmnet(XA,YA,alpha=0,lambda=tmp$lambda.min)\n  RES[bloc==i,\"lasso\"] <- predict(mod,XT)\n  ###elastic\n  tmp <- cv.glmnet(XA,YA,alpha=0.5)\n  mod <- glmnet(XA,YA,alpha=.5,lambda=tmp$lambda.min)\n  RES[bloc==i,\"elastic\"] <- predict(mod,XT)\n}\n```\n:::\n\n\n## Régressions sur composantes\n\nChargement du package pour les régressions sur composantes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pls)\n```\n:::\n\n\nÉvaluation de la qualité prédictive des régressions PCR et PLS\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:nbbloc){\n   #####PLS\n   tmp <- plsr(maxO3~.,data=ozone[bloc!=i,],ncomp=20,\n                                 validation=\"CV\",scale=TRUE)\n   mse <- MSEP(tmp,estimate=c(\"train\",\"CV\"))\n   npls <- which.min(mse$val[\"CV\",,])-1 \n   mod <- plsr(maxO3~.,ncomp=npls,data=ozone[bloc!=i,],scale=TRUE)\n   RES[bloc==i,\"PLS\"] <- predict(mod,ozone[bloc==i,],ncomp=npls)\n   #####PCR\n   tmp <- pcr(maxO3~.,data=ozone[bloc!=i,],ncomp=20,\n                                    validation=\"CV\",scale=TRUE)\n   mse <- MSEP(tmp,estimate=c(\"train\",\"CV\"))\n   npcr <- which.min(mse$val[\"CV\",,])-1 \n   mod <- pcr(maxO3~.,ncomp=npcr,data=ozone[bloc!=i,],scale=TRUE)\n   RES[bloc==i,\"PCR\"] <- predict(mod,ozone[bloc==i,],ncomp=npcr)\n }\n```\n:::\n\n\nLes résultats :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRES |> \n  dplyr::summarise(across(-Y,~mean((Y-.)^2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       MCO    choix    ridge    lasso  elastic      PLS      PCR\n1 187.2726 188.8491 187.8304 187.1023 187.0389 187.2622 187.2685\n```\n:::\n:::\n\n\n# Pour aller plus loin\n\nCréation d'un data-frame pour les résultats :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_rep <- data.frame(MCO=0,choix=0,ridge=0,lasso=0,elastic=0)\n```\n:::\n\n\n\n## Régression linéaire\n\nLa fonction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsse_reg <- function(don,bloc,b) {\n    m_reg <- lm(maxO3~.,data=don[bloc!=b,])\n    previsions <- predict(m_reg,don[bloc==b,])\n    return(sum((don[bloc==b,\"maxO3\"]-previsions)^2))\n}\n```\n:::\n\n\nLa qualité de la modélisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nssereg  <- rep(0,20)\nfor (r in 1:20) {\n  bloc <- sample(blocseq)\n  for(b in 1:nbbloc){\n    ssereg[r] <- ssereg[r] + sse_reg(ozone,bloc,b)\n  }\n}\nres_rep$MCO <- round(mean(ssereg/nrow(ozone)),2)\n```\n:::\n\n\n## Choix de variables\n\nLa fonction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaps)\nsse_regbic <- function(don,bloc,b,nvmax,method) {\n    recherche <- regsubsets(maxO3~., int=T, nbest=1,data=don[bloc!=b,],\n                           nvmax=nvmax,method=method)\n    resume <- summary(recherche)\n    nomselec <- colnames(resume$which)[resume$which[which.min(resume$bic),]][-1]\n    formule <- formula(paste(\"maxO3 ~\", paste(nomselec, collapse = \"+\")))\n    m_reg <- lm(formule,data=don[bloc!=b,])\n    previsions <- predict(m_reg,don[bloc==b,])\n    return(sum((don[bloc==b,\"maxO3\"]-previsions)^2))\n}\n```\n:::\n\n\nLa qualité de la modélisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nsseregbic <-  rep(0,20)\nfor (r in 1:20) {\n  bloc <- sample(blocseq)\n  for(b in 1:nbbloc){\n    sseregbic[r] <- sseregbic[r] + sse_regbic(ozone,bloc,b,22,\"exhaustive\")\n  }\n}\nres_rep$choix <- mean(sseregbic/nrow(ozone))\n```\n:::\n\n\n## Lasso\n\nLa fonction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glmnet)\nsse_glmnet <- function(X,Y,bloc,b,a) {\n  rech <- cv.glmnet(X[bloc!=b,], Y[bloc!=b,drop=FALSE], alpha=a)\n  prev <- predict(rech, newx=X[bloc==b,], s=rech$lambda.min)\n  return(sum((Y[bloc==b,\"maxO3\"] - as.vector(prev))^2))\n}\n```\n:::\n\n\nLa qualité de la modélisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <-  model.matrix(maxO3~.,data=ozone)[,-1]\nY <- data.matrix(ozone[,\"maxO3\",drop=FALSE])\nset.seed(1234)\nsselasso <- rep(0,20)\nfor (r in 1:20) {\n  bloc <- sample(blocseq)\n  for(b in 1:nbbloc){\n      sselasso[r] <- sselasso[r] + sse_glmnet(X,Y,bloc,b,a=1)\n  }\n}\nres_rep$lasso <- round(mean(sselasso/nrow(ozone)),2)\n```\n:::\n\n\n\n## RIDGE\n\nLa qualité de la modélisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <-  model.matrix(maxO3~.,data=ozone)[,-1]\nY <- data.matrix(ozone[,\"maxO3\",drop=FALSE])\nset.seed(1234)\nsseridge <- rep(0,20)\nfor (r in 1:20) {\n  bloc <- sample(blocseq)\n  for(b in 1:nbbloc){\n      sseridge[r] <- sseridge[r] + sse_glmnet(X,Y,bloc,b,a=0)\n  }\n}\nres_rep$ridge <- mean(sseridge/nrow(ozone))\n```\n:::\n\n\n## Elastic-net\n\nLa qualité de la modélisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX <-  model.matrix(maxO3~.,data=ozone)[,-1]\nY <- data.matrix(ozone[,\"maxO3\",drop=FALSE])\nset.seed(1234)\nsseelasticnet <- rep(0,20)\nfor (r in 1:20) {\n  bloc <- sample(blocseq)\n  for(b in 1:nbbloc){\n      sseelasticnet[r] <- sseelasticnet[r] + sse_glmnet(X,Y,bloc,b,a=0.5)\n  }\n}\nres_rep$elastic <- mean(sseelasticnet/nrow(ozone))\n```\n:::\n\n\nLes résultats\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_rep\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     MCO    choix    ridge  lasso  elastic\n1 188.36 189.6025 188.6624 187.92 187.8242\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}